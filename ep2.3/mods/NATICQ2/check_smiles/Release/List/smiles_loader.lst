##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    21/Mar/2009  21:21:19 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\pasha\elf\_MY_PROJECT_\_NATICQ2\check_smiles\smil #
#                       es_loader.c                                          #
#    Command line    =  D:\pasha\elf\_MY_PROJECT_\_NATICQ2\check_smiles\smil #
#                       es_loader.c -lC D:\pasha\elf\_MY_PROJECT_\_NATICQ2\c #
#                       heck_smiles\Release\List\ -o                         #
#                       D:\pasha\elf\_MY_PROJECT_\_NATICQ2\check_smiles\Rele #
#                       ase\Obj\ -s9 --no_unroll --cpu_mode arm --endian     #
#                       little --cpu ARM926EJ-S --stack_align 4 --interwork  #
#                       -e --fpu None -I "D:\pasha\Embedded Workbench 4.0    #
#                       Evaluation2\ARM\INC\" --inline_threshold=2           #
#    List file       =  D:\pasha\elf\_MY_PROJECT_\_NATICQ2\check_smiles\Rele #
#                       ase\List\smiles_loader.lst                           #
#    Object file     =  D:\pasha\elf\_MY_PROJECT_\_NATICQ2\check_smiles\Rele #
#                       ase\Obj\smiles_loader.r79                            #
#                                                                            #
#                                                                            #
##############################################################################

D:\pasha\elf\_MY_PROJECT_\_NATICQ2\check_smiles\smiles_loader.c
      1          #include "../inc/swilib.h"
      2          #include "../inc/pnglist.h"
      3          #include "../naticq_ipc.h"
      4          #include "../smiles.h"
      5          #include "../naticq.h"
      6          #include "../strings.h"
      7          #include "../readimg.h"
      8          #include "smiles_loader.h"
      9          

   \                                 In segment DATA_Z, align 4, align-sorted
     10          S_SMILES *s_top=0;
     11          
     12          DYNPNGICONLIST *SmilesImgList;
     13          
     14          volatile int total_smiles;
     15          volatile int total_xstatuses;
     16          volatile int xstatuses_load;
     17          volatile int pictures_max;
     18          volatile int pictures_loaded;
     19          
     20          extern const char SMILE_FILE[];
     21          extern const char SMILE_PATH[];
     22          extern const char XSTATUSES_PATH[];
     23          extern const char ipc_my_name[32];
     24          extern  int S_ICONS[];
     25          
     26          static IPC_REQ gipc;
   \                     gipc:
   \   00000000                      DS8 12
   \                     s_top:
   \   0000000C                      DS8 4
   \                     SmilesImgList:
   \   00000010                      DS8 4
   \                     total_smiles:
   \   00000014                      DS8 4
   \                     pictures_max:
   \   00000018                      DS8 4
   \                     pictures_loaded:
   \   0000001C                      DS8 4
   \   00000020                      DS8 4
   \   00000024                      DS8 4
   \   00000028                      DS8 4
   \   0000002C                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     total_xstatuses:
   \   00000000                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     xstatuses_load:
   \   00000000                      DS8 4
     27          static char *p_buf;
     28          static char *s_buf;
     29          static S_SMILES *s_bot;
     30          static int n_pic;
     31          
     32          

   \                                 In segment CODE, align 4, keep-with-next
     33          void FreeSmiles(void)
     34          {
   \                     FreeSmiles:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
     35            S_SMILES *s_smile;
     36            STXT_SMILES *n;
     37            STXT_SMILES *st;
     38            DYNPNGICONLIST *d;
     39            DYNPNGICONLIST *nd;
     40            LockSched();
     41            total_smiles=0;
   \   00000004   ........           LDR      R4,??DataTable5  ;; gipc
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0050A0E3           MOV      R5,#+0
   \   00000010   460100EF           SWI      +326
   \   00000014   145084E5           STR      R5,[R4, #+20]
     42            s_smile=(S_SMILES *)s_top;
   \   00000018   0C6094E5           LDR      R6,[R4, #+12]
     43            s_top=0;
   \   0000001C   0C5084E5           STR      R5,[R4, #+12]
     44            s_bot=0;
   \   00000020   285084E5           STR      R5,[R4, #+40]
     45            UnlockSched();
   \   00000024   470100EF           SWI      +327
   \   00000028   000056E3           CMP      R6,#+0
   \   0000002C   1300000A           BEQ      ??FreeSmiles_0
     46            while(s_smile)
     47            {
     48              S_SMILES *s;
     49              s=s_smile;
   \                     ??FreeSmiles_1:
   \   00000030   0670A0E1           MOV      R7,R6
     50              st=s->lines;
   \   00000034   080097E5           LDR      R0,[R7, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0A00000A           BEQ      ??FreeSmiles_2
     51              while(st)
     52              {
     53                n=st->next;
   \                     ??FreeSmiles_3:
   \   00000040   0010A0E3           MOV      R1,#+0
   \   00000044   0D20A0E1           MOV      R2,SP
   \                     ??FreeSmiles_4:
   \   00000048   0030D1E7           LDRB     R3,[R1, +R0]
   \   0000004C   0230C1E7           STRB     R3,[R1, +R2]
   \   00000050   011081E2           ADD      R1,R1,#+1
   \   00000054   040051E3           CMP      R1,#+4
   \   00000058   FAFFFFBA           BLT      ??FreeSmiles_4
   \   0000005C   00809DE5           LDR      R8,[SP, #+0]
     54                mfree(st);
   \   00000060   150000EF           SWI      +21
     55                st=n;
   \   00000064   0800B0E1           MOVS     R0,R8
     56              }
   \   00000068   F4FFFF1A           BNE      ??FreeSmiles_3
     57              s_smile=(S_SMILES *)(s_smile->next);
   \                     ??FreeSmiles_2:
   \   0000006C   006096E5           LDR      R6,[R6, #+0]
     58              mfree(s);
   \   00000070   0700A0E1           MOV      R0,R7
   \   00000074   150000EF           SWI      +21
     59            }
   \   00000078   000056E3           CMP      R6,#+0
   \   0000007C   EBFFFF1A           BNE      ??FreeSmiles_1
     60            LockSched();
   \                     ??FreeSmiles_0:
   \   00000080   460100EF           SWI      +326
     61            d=SmilesImgList;
   \   00000084   106094E5           LDR      R6,[R4, #+16]
     62            SmilesImgList=0;
   \   00000088   105084E5           STR      R5,[R4, #+16]
     63            UnlockSched();
   \   0000008C   470100EF           SWI      +327
   \   00000090   000056E3           CMP      R6,#+0
   \   00000094   0B00000A           BEQ      ??FreeSmiles_5
     64            while(d)
     65            {
     66              if (d->img)
   \                     ??FreeSmiles_6:
   \   00000098   080096E5           LDR      R0,[R6, #+8]
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   0300000A           BEQ      ??FreeSmiles_7
     67              {
     68                mfree(d->img->bitmap);
   \   000000A4   040090E5           LDR      R0,[R0, #+4]
   \   000000A8   150000EF           SWI      +21
     69                mfree(d->img);
   \   000000AC   080096E5           LDR      R0,[R6, #+8]
   \   000000B0   150000EF           SWI      +21
     70              }
     71              nd=d->next;
   \                     ??FreeSmiles_7:
   \   000000B4   005096E5           LDR      R5,[R6, #+0]
     72              mfree(d);
   \   000000B8   0600A0E1           MOV      R0,R6
   \   000000BC   150000EF           SWI      +21
     73              d=nd;
   \   000000C0   0560B0E1           MOVS     R6,R5
     74            }
   \   000000C4   F3FFFF1A           BNE      ??FreeSmiles_6
     75            mfree(s_buf);
   \                     ??FreeSmiles_5:
   \   000000C8   240094E5           LDR      R0,[R4, #+36]
   \   000000CC   150000EF           SWI      +21
     76          }
   \   000000D0   F181BDE8           POP      {R0,R4-R8,PC}    ;; return
     77          

   \                                 In segment CODE, align 4, keep-with-next
     78          void InitSmiles(void)
     79          {
   \                     InitSmiles:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
     80            int f;
     81            unsigned int err;
     82            int fsize;
     83            char *buf;
     84            FSTATS stat;
     85          
     86            FreeSmiles();
     87          
     88            n_pic=FIRST_UCS2_BITMAP;
   \   00000004   ........           LDR      R4,??DataTable8  ;; gipc
     89            if (GetFileStats(SMILE_FILE,&stat,&err)==-1)
   \   00000008   ........           LDR      R6,??DataTable4  ;; SMILE_FILE
   \   0000000C   2CD04DE2           SUB      SP,SP,#+44
   \   00000010   ........           BL       FreeSmiles
   \   00000014   3700A0E3           MOV      R0,#+55
   \   00000018   E10C80E3           ORR      R0,R0,#0xE100
   \   0000001C   2C0084E5           STR      R0,[R4, #+44]
   \   00000020   0050E0E3           MVN      R5,#+0
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   04108DE2           ADD      R1,SP,#+4
   \   0000002C   0600A0E1           MOV      R0,R6
   \   00000030   840000EF           SWI      +132
   \   00000034   050050E1           CMP      R0,R5
   \   00000038   2300000A           BEQ      ??InitSmiles_0
     90              return;
     91          
     92            if ((fsize=stat.size)<=0)
   \   0000003C   08709DE5           LDR      R7,[SP, #+8]
   \   00000040   010057E3           CMP      R7,#+1
   \   00000044   200000BA           BLT      ??InitSmiles_0
     93              return;
     94          
     95            if ((f=fopen(SMILE_FILE,A_ReadOnly+A_BIN,P_READ,&err))==-1)
   \   00000048   0D30A0E1           MOV      R3,SP
   \   0000004C   8020A0E3           MOV      R2,#+128
   \   00000050   801CA0E3           MOV      R1,#+32768
   \   00000054   0600A0E1           MOV      R0,R6
   \   00000058   0A0000EF           SWI      +10
   \   0000005C   0060A0E1           MOV      R6,R0
   \   00000060   050056E1           CMP      R6,R5
   \   00000064   1800000A           BEQ      ??InitSmiles_0
     96              return;
     97          
     98            buf=s_buf=p_buf=malloc(fsize+1);
   \   00000068   010087E2           ADD      R0,R7,#+1
   \   0000006C   140000EF           SWI      +20
   \   00000070   0050A0E1           MOV      R5,R0
   \   00000074   205084E5           STR      R5,[R4, #+32]
   \   00000078   245084E5           STR      R5,[R4, #+36]
     99            buf[fread(f,buf,fsize,&err)]=0;
   \   0000007C   0080A0E3           MOV      R8,#+0
   \   00000080   0D30A0E1           MOV      R3,SP
   \   00000084   0720A0E1           MOV      R2,R7
   \   00000088   0510A0E1           MOV      R1,R5
   \   0000008C   0600A0E1           MOV      R0,R6
   \   00000090   0B0000EF           SWI      +11
   \   00000094   0580C0E7           STRB     R8,[R0, +R5]
    100            fclose(f,&err);
   \   00000098   0D10A0E1           MOV      R1,SP
   \   0000009C   0600A0E1           MOV      R0,R6
   \   000000A0   0D0000EF           SWI      +13
    101            //f=fopen("4:\\smiles.cfg",A_ReadWrite+A_BIN+A_Create+A_Append,P_READ+P_WRITE,&err);
    102            gipc.name_to=ipc_my_name;
   \   000000A4   ........           LDR      R0,??DataTable7  ;; ipc_my_name
    103            gipc.name_from=ipc_my_name;
    104            gipc.data=0;
   \   000000A8   088084E5           STR      R8,[R4, #+8]
   \   000000AC   000084E5           STR      R0,[R4, #+0]
   \   000000B0   040084E5           STR      R0,[R4, #+4]
    105                
    106            GBS_SendMessage(MMI_CEPID,MSG_IPC,IPC_SMILE_PROCESSED,&gipc);
   \   000000B4   0430A0E1           MOV      R3,R4
   \   000000B8   0220A0E3           MOV      R2,#+2
   \   000000BC   FC1F82E3           ORR      R1,R2,#0x3F0
   \   000000C0   0900A0E3           MOV      R0,#+9
   \   000000C4   420C80E3           ORR      R0,R0,#0x4200
   \   000000C8   000100EF           SWI      +256
    107          }
   \                     ??InitSmiles_0:
   \   000000CC   2CD08DE2           ADD      SP,SP,#+44       ;; stack cleaning
   \   000000D0   F081BDE8           POP      {R4-R8,PC}       ;; return
    108          

   \                                 In segment CODE, align 4, keep-with-next
    109          void CheckSmiles(void)
    110          {
   \                     CheckSmiles:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
    111            int f;
    112            unsigned int err;
    113            int fsize;
    114            char *buf, *p_buf;
    115            FSTATS stat;
    116          
    117            if (GetFileStats(SMILE_FILE,&stat,&err)==-1)
   \   00000004   ........           LDR      R5,??DataTable4  ;; SMILE_FILE
   \   00000008   2CD04DE2           SUB      SP,SP,#+44
   \   0000000C   0040E0E3           MVN      R4,#+0
   \   00000010   0D20A0E1           MOV      R2,SP
   \   00000014   04108DE2           ADD      R1,SP,#+4
   \   00000018   0500A0E1           MOV      R0,R5
   \   0000001C   840000EF           SWI      +132
   \   00000020   040050E1           CMP      R0,R4
   \   00000024   2C00000A           BEQ      ??CheckSmiles_0
    118              return;
    119          
    120            if ((fsize=stat.size)<=0)
   \   00000028   08609DE5           LDR      R6,[SP, #+8]
   \   0000002C   010056E3           CMP      R6,#+1
   \   00000030   290000BA           BLT      ??CheckSmiles_0
    121              return;
    122          
    123            if ((f=fopen(SMILE_FILE,A_ReadOnly+A_BIN,P_READ,&err))==-1)
   \   00000034   0D30A0E1           MOV      R3,SP
   \   00000038   8020A0E3           MOV      R2,#+128
   \   0000003C   801CA0E3           MOV      R1,#+32768
   \   00000040   0500A0E1           MOV      R0,R5
   \   00000044   0A0000EF           SWI      +10
   \   00000048   0070A0E1           MOV      R7,R0
   \   0000004C   040057E1           CMP      R7,R4
   \   00000050   2100000A           BEQ      ??CheckSmiles_0
    124              return;
    125          
    126            buf=p_buf=malloc(fsize+1);
   \   00000054   010086E2           ADD      R0,R6,#+1
   \   00000058   140000EF           SWI      +20
   \   0000005C   0040A0E1           MOV      R4,R0
    127            buf[fread(f,buf,fsize,&err)]=0;
   \   00000060   0D30A0E1           MOV      R3,SP
   \   00000064   0620A0E1           MOV      R2,R6
   \   00000068   0410A0E1           MOV      R1,R4
   \   0000006C   0700A0E1           MOV      R0,R7
   \   00000070   0B0000EF           SWI      +11
   \   00000074   0010A0E3           MOV      R1,#+0
   \   00000078   0410C0E7           STRB     R1,[R0, +R4]
    128            fclose(f,&err);
   \   0000007C   0D10A0E1           MOV      R1,SP
   \   00000080   0700A0E1           MOV      R0,R7
   \   00000084   0D0000EF           SWI      +13
    129            
    130            f = pictures_max;
   \   00000088   ........           LDR      R0,??DataTable5  ;; gipc
   \   0000008C   0450A0E1           MOV      R5,R4
   \   00000090   181090E5           LDR      R1,[R0, #+24]
    131            for(buf=p_buf;*buf; buf++)
   \   00000094   0010D5E5           LDRB     R1,[R5, #+0]
   \   00000098   000051E3           CMP      R1,#+0
   \   0000009C   0C00000A           BEQ      ??CheckSmiles_1
    132              if(*buf == ':')
   \                     ??CheckSmiles_2:
   \   000000A0   0010D5E5           LDRB     R1,[R5, #+0]
   \   000000A4   3A0051E3           CMP      R1,#+58
   \   000000A8   0600001A           BNE      ??CheckSmiles_3
    133              {
    134                buf++;
    135                while(*buf && *buf != 0x0D) buf++;
   \                     ??CheckSmiles_4:
   \   000000AC   0110F5E5           LDRB     R1,[R5, #+1]!
   \   000000B0   000051E3           CMP      R1,#+0
   \   000000B4   0D005113           CMPNE    R1,#+13
   \   000000B8   FBFFFF1A           BNE      ??CheckSmiles_4
    136                pictures_max++;
   \   000000BC   181090E5           LDR      R1,[R0, #+24]
   \   000000C0   011081E2           ADD      R1,R1,#+1
   \   000000C4   181080E5           STR      R1,[R0, #+24]
    137              }
   \                     ??CheckSmiles_3:
   \   000000C8   0110F5E5           LDRB     R1,[R5, #+1]!
   \   000000CC   000051E3           CMP      R1,#+0
   \   000000D0   F2FFFF1A           BNE      ??CheckSmiles_2
    138          /*  if(f == pictures_max)                 //А вдруг у нас кривые переводы строк?
    139            {
    140              for(buf=p_buf;*buf; buf++)
    141              if(*buf == 0x0A)
    142              {
    143                buf++;
    144                while(*buf && *buf != 0x0A && *buf!=':') buf++;
    145                if(*buf!=':') pictures_max++;
    146              }
    147            }*/
    148            mfree(p_buf);
   \                     ??CheckSmiles_1:
   \   000000D4   0400A0E1           MOV      R0,R4
   \   000000D8   150000EF           SWI      +21
    149          }
   \                     ??CheckSmiles_0:
   \   000000DC   2CD08DE2           ADD      SP,SP,#+44       ;; stack cleaning
   \   000000E0   F080BDE8           POP      {R4-R7,PC}       ;; return
    150          

   \                                 In segment CODE, align 4, keep-with-next
    151          void ProcessNextSmile(void)  
    152          {  
   \                     ProcessNextSmile:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
    153            int c;
    154            char fn[128];
    155            DYNPNGICONLIST *dp;
    156            S_SMILES *si;
    157            STXT_SMILES *st;
    158            char *buf=p_buf;
   \   00000004   ........           LDR      R4,??DataTable8  ;; gipc
   \   00000008   84D04DE2           SUB      SP,SP,#+132
   \   0000000C   206094E5           LDR      R6,[R4, #+32]
    159            if (!buf) return;
   \   00000010   0050A0E3           MOV      R5,#+0
   \   00000014   000056E3           CMP      R6,#+0
   \   00000018   0600001A           BNE      ??ProcessNextSmile_0
   \   0000001C   170000EA           B        ??ProcessNextSmile_1
    160            while ((c=*buf))
    161            {
    162              char *p;
    163              if ((c==10)||(c==13))
    164              {
    165                buf++;
    166                gipc.name_to=ipc_my_name;
    167                gipc.name_from=ipc_my_name;
    168                gipc.data=0;
    169                GBS_SendMessage(MMI_CEPID,MSG_IPC,IPC_SMILE_PROCESSED,&gipc);
    170                p_buf=buf;
    171                return;
    172              }
    173              p=strchr(buf,':');
    174              if (!p) break;
    175              zeromem(fn,128);
    176              strcpy(fn,SMILE_PATH);
    177              if (fn[strlen(fn)-1]!='\\') strcat(fn,"\\");
    178              c=p-buf;
    179              if (c>(127-strlen(fn))) break;
    180              strncpy(fn+strlen(fn),buf,c);
    181          //    snprintf(logmsg,255,"Process file %s...",fn);
    182          //    REDRAW();
    183              buf=p;
    184              dp=malloc(sizeof(DYNPNGICONLIST));
    185              zeromem(dp,sizeof(DYNPNGICONLIST));
    186              dp->icon=GetPicNByUnicodeSymbol(n_pic);
    187              dp->img=CreateIMGHDRFromPngFile(fn,0);
    188              LockSched();
    189              if (SmilesImgList)
    190              {
    191                dp->next=SmilesImgList;
    192              }
    193              SmilesImgList=dp;
    194              UnlockSched();
    195              si=malloc(sizeof(S_SMILES));
    196              si->next=NULL;
    197              si->lines=NULL;
    198              si->botlines=NULL;
    199              si->uni_smile=n_pic;
    200              if (s_bot)
    201              {
    202                //Не первый
    203                s_bot->next=si;
    204                s_bot=si;
    205              }
    206              else
    207              {
    208                //Первый
    209                s_top=si;
    210                s_bot=si;
    211              }
    212              n_pic++;
    213              while (*buf!=10 && *buf!=13 && *buf!=0)
    214              {
    215                buf++;
    216                int i=0;
    217                while (buf[i]!=0&&buf [i]!=','&&buf [i]!=10&&buf[i]!=13)  i++;
    218                st=malloc(sizeof(STXT_SMILES)+i);
    219                strncpy(st->text,buf,i);
    220                st->text[i]=0;
    221                
    222                st->next=NULL;
    223                st->key=*((unsigned long *)st->text);
    224                st->mask=~(0xFFFFFFFFUL<<(8*i));
    225                st->key&=st->mask;
    226                if (si->botlines)
    227                {
    228          	si->botlines->next=st;
    229          	si->botlines=st;
    230                }
    231                else
    232                {
    233          	si->lines=st;
    234          	si->botlines=st;
    235                }
    236                buf+=i;
    237              }
    238              pictures_loaded++;
   \                     ??ProcessNextSmile_2:
   \   00000020   1C0094E5           LDR      R0,[R4, #+28]
   \   00000024   010080E2           ADD      R0,R0,#+1
   \   00000028   1C0084E5           STR      R0,[R4, #+28]
    239              total_smiles++;
   \   0000002C   140094E5           LDR      R0,[R4, #+20]
   \   00000030   010080E2           ADD      R0,R0,#+1
   \   00000034   140084E5           STR      R0,[R4, #+20]
   \                     ??ProcessNextSmile_0:
   \   00000038   0080D6E5           LDRB     R8,[R6, #+0]
   \   0000003C   000058E3           CMP      R8,#+0
   \   00000040   AF00000A           BEQ      ??ProcessNextSmile_3
   \   00000044   0A0058E3           CMP      R8,#+10
   \   00000048   0D005813           CMPNE    R8,#+13
   \   0000004C   0D00001A           BNE      ??ProcessNextSmile_4
   \   00000050   ........           LDR      R0,??DataTable7  ;; ipc_my_name
   \   00000054   085084E5           STR      R5,[R4, #+8]
   \   00000058   000084E5           STR      R0,[R4, #+0]
   \   0000005C   040084E5           STR      R0,[R4, #+4]
   \   00000060   0430A0E1           MOV      R3,R4
   \   00000064   0220A0E3           MOV      R2,#+2
   \   00000068   FC1F82E3           ORR      R1,R2,#0x3F0
   \   0000006C   0900A0E3           MOV      R0,#+9
   \   00000070   420C80E3           ORR      R0,R0,#0x4200
   \   00000074   000100EF           SWI      +256
   \   00000078   016086E2           ADD      R6,R6,#+1
   \   0000007C   206084E5           STR      R6,[R4, #+32]
   \                     ??ProcessNextSmile_1:
   \   00000080   84D08DE2           ADD      SP,SP,#+132
   \   00000084   F083BDE8           POP      {R4-R9,PC}
   \                     ??ProcessNextSmile_4:
   \   00000088   3A10A0E3           MOV      R1,#+58
   \   0000008C   0600A0E1           MOV      R0,R6
   \   00000090   180000EF           SWI      +24
   \   00000094   0070B0E1           MOVS     R7,R0
   \   00000098   9900000A           BEQ      ??ProcessNextSmile_3
   \   0000009C   8010A0E3           MOV      R1,#+128
   \   000000A0   04008DE2           ADD      R0,SP,#+4
   \   000000A4   1D0100EF           SWI      +285
   \   000000A8   78129FE5           LDR      R1,??ProcessNextSmile_5+0x4  ;; SMILE_PATH
   \   000000AC   04008DE2           ADD      R0,SP,#+4
   \   000000B0   1A0000EF           SWI      +26
   \   000000B4   04008DE2           ADD      R0,SP,#+4
   \   000000B8   1B0000EF           SWI      +27
   \   000000BC   04108DE2           ADD      R1,SP,#+4
   \   000000C0   010080E0           ADD      R0,R0,R1
   \   000000C4   010050E5           LDRB     R0,[R0, #-1]
   \   000000C8   5C0050E3           CMP      R0,#+92
   \   000000CC   0200000A           BEQ      ??ProcessNextSmile_6
   \   000000D0   931F8FE2           ADR      R1,??ProcessNextSmile_5  ;; "\\"
   \   000000D4   04008DE2           ADD      R0,SP,#+4
   \   000000D8   170000EF           SWI      +23
   \                     ??ProcessNextSmile_6:
   \   000000DC   068047E0           SUB      R8,R7,R6
   \   000000E0   04008DE2           ADD      R0,SP,#+4
   \   000000E4   1B0000EF           SWI      +27
   \   000000E8   7F0060E2           RSB      R0,R0,#+127
   \   000000EC   080050E1           CMP      R0,R8
   \   000000F0   8300003A           BCC      ??ProcessNextSmile_3
   \   000000F4   04008DE2           ADD      R0,SP,#+4
   \   000000F8   1B0000EF           SWI      +27
   \   000000FC   0820A0E1           MOV      R2,R8
   \   00000100   0610A0E1           MOV      R1,R6
   \   00000104   04308DE2           ADD      R3,SP,#+4
   \   00000108   030080E0           ADD      R0,R0,R3
   \   0000010C   160100EF           SWI      +278
   \   00000110   0760A0E1           MOV      R6,R7
   \   00000114   0C00A0E3           MOV      R0,#+12
   \   00000118   140000EF           SWI      +20
   \   0000011C   0070A0E1           MOV      R7,R0
   \   00000120   0C10A0E3           MOV      R1,#+12
   \   00000124   1D0100EF           SWI      +285
   \   00000128   2C0094E5           LDR      R0,[R4, #+44]
   \   0000012C   E40100EF           SWI      +484
   \   00000130   040087E5           STR      R0,[R7, #+4]
   \   00000134   0010A0E3           MOV      R1,#+0
   \   00000138   04008DE2           ADD      R0,SP,#+4
   \   0000013C   E90100EF           SWI      +489
   \   00000140   080087E5           STR      R0,[R7, #+8]
   \   00000144   460100EF           SWI      +326
   \   00000148   100094E5           LDR      R0,[R4, #+16]
   \   0000014C   000050E3           CMP      R0,#+0
   \   00000150   00008715           STRNE    R0,[R7, #+0]
   \   00000154   107084E5           STR      R7,[R4, #+16]
   \   00000158   470100EF           SWI      +327
   \   0000015C   1000A0E3           MOV      R0,#+16
   \   00000160   140000EF           SWI      +20
   \   00000164   0070A0E1           MOV      R7,R0
   \   00000168   005087E5           STR      R5,[R7, #+0]
   \   0000016C   085087E5           STR      R5,[R7, #+8]
   \   00000170   0C5087E5           STR      R5,[R7, #+12]
   \   00000174   2C0094E5           LDR      R0,[R4, #+44]
   \   00000178   040087E5           STR      R0,[R7, #+4]
   \   0000017C   281094E5           LDR      R1,[R4, #+40]
   \   00000180   010080E2           ADD      R0,R0,#+1
   \   00000184   000051E3           CMP      R1,#+0
   \   00000188   00708115           STRNE    R7,[R1, #+0]
   \   0000018C   0C708405           STREQ    R7,[R4, #+12]
   \   00000190   0710A0E1           MOV      R1,R7
   \   00000194   281084E5           STR      R1,[R4, #+40]
   \   00000198   2C0084E5           STR      R0,[R4, #+44]
   \   0000019C   020000EA           B        ??ProcessNextSmile_7
   \                     ??ProcessNextSmile_8:
   \   000001A0   089087E5           STR      R9,[R7, #+8]
   \                     ??ProcessNextSmile_9:
   \   000001A4   0C9087E5           STR      R9,[R7, #+12]
   \   000001A8   066088E0           ADD      R6,R8,R6
   \                     ??ProcessNextSmile_7:
   \   000001AC   0000D6E5           LDRB     R0,[R6, #+0]
   \   000001B0   0A0050E3           CMP      R0,#+10
   \   000001B4   0D005013           CMPNE    R0,#+13
   \   000001B8   00005013           CMPNE    R0,#+0
   \   000001BC   97FFFF0A           BEQ      ??ProcessNextSmile_2
   \   000001C0   016086E2           ADD      R6,R6,#+1
   \   000001C4   0080A0E3           MOV      R8,#+0
   \   000001C8   000000EA           B        ??ProcessNextSmile_10
   \                     ??ProcessNextSmile_11:
   \   000001CC   018088E2           ADD      R8,R8,#+1
   \                     ??ProcessNextSmile_10:
   \   000001D0   0600D8E7           LDRB     R0,[R8, +R6]
   \   000001D4   000050E3           CMP      R0,#+0
   \   000001D8   2C005013           CMPNE    R0,#+44
   \   000001DC   0A005013           CMPNE    R0,#+10
   \   000001E0   0D005013           CMPNE    R0,#+13
   \   000001E4   F8FFFF1A           BNE      ??ProcessNextSmile_11
   \   000001E8   0D0088E2           ADD      R0,R8,#+13
   \   000001EC   140000EF           SWI      +20
   \   000001F0   0090A0E1           MOV      R9,R0
   \   000001F4   0820A0E1           MOV      R2,R8
   \   000001F8   0610A0E1           MOV      R1,R6
   \   000001FC   0C0089E2           ADD      R0,R9,#+12
   \   00000200   160100EF           SWI      +278
   \   00000204   090088E0           ADD      R0,R8,R9
   \   00000208   0C50C0E5           STRB     R5,[R0, #+12]
   \   0000020C   00508DE5           STR      R5,[SP, #+0]
   \   00000210   0000A0E3           MOV      R0,#+0
   \                     ??ProcessNextSmile_12:
   \   00000214   0D10A0E1           MOV      R1,SP
   \   00000218   0110D0E7           LDRB     R1,[R0, +R1]
   \   0000021C   0910C0E7           STRB     R1,[R0, +R9]
   \   00000220   010080E2           ADD      R0,R0,#+1
   \   00000224   040050E3           CMP      R0,#+4
   \   00000228   F9FFFFBA           BLT      ??ProcessNextSmile_12
   \   0000022C   0C0099E5           LDR      R0,[R9, #+12]
   \   00000230   0810A0E1           MOV      R1,R8
   \   00000234   0400C9E5           STRB     R0,[R9, #+4]
   \   00000238   2004A0E1           LSR      R0,R0,#+8
   \   0000023C   0500C9E5           STRB     R0,[R9, #+5]
   \   00000240   2004A0E1           LSR      R0,R0,#+8
   \   00000244   0600C9E5           STRB     R0,[R9, #+6]
   \   00000248   2004A0E1           LSR      R0,R0,#+8
   \   0000024C   0700C9E5           STRB     R0,[R9, #+7]
   \   00000250   0500E0E1           MVN      R0,R5
   \   00000254   8111A0E1           LSL      R1,R1,#+3
   \   00000258   1001E0E1           MVN      R0,R0, LSL R1
   \   0000025C   0800C9E5           STRB     R0,[R9, #+8]
   \   00000260   2004A0E1           LSR      R0,R0,#+8
   \   00000264   0900C9E5           STRB     R0,[R9, #+9]
   \   00000268   2004A0E1           LSR      R0,R0,#+8
   \   0000026C   0A00C9E5           STRB     R0,[R9, #+10]
   \   00000270   2004A0E1           LSR      R0,R0,#+8
   \   00000274   0B00C9E5           STRB     R0,[R9, #+11]
   \   00000278   0700D9E5           LDRB     R0,[R9, #+7]
   \   0000027C   0610D9E5           LDRB     R1,[R9, #+6]
   \   00000280   0A20D9E5           LDRB     R2,[R9, #+10]
   \   00000284   000481E1           ORR      R0,R1,R0, LSL #+8
   \   00000288   0510D9E5           LDRB     R1,[R9, #+5]
   \   0000028C   000481E1           ORR      R0,R1,R0, LSL #+8
   \   00000290   0410D9E5           LDRB     R1,[R9, #+4]
   \   00000294   000481E1           ORR      R0,R1,R0, LSL #+8
   \   00000298   0B10D9E5           LDRB     R1,[R9, #+11]
   \   0000029C   011482E1           ORR      R1,R2,R1, LSL #+8
   \   000002A0   0920D9E5           LDRB     R2,[R9, #+9]
   \   000002A4   011482E1           ORR      R1,R2,R1, LSL #+8
   \   000002A8   0820D9E5           LDRB     R2,[R9, #+8]
   \   000002AC   011482E1           ORR      R1,R2,R1, LSL #+8
   \   000002B0   000001E0           AND      R0,R1,R0
   \   000002B4   0400C9E5           STRB     R0,[R9, #+4]
   \   000002B8   2004A0E1           LSR      R0,R0,#+8
   \   000002BC   0500C9E5           STRB     R0,[R9, #+5]
   \   000002C0   2004A0E1           LSR      R0,R0,#+8
   \   000002C4   0600C9E5           STRB     R0,[R9, #+6]
   \   000002C8   2004A0E1           LSR      R0,R0,#+8
   \   000002CC   0700C9E5           STRB     R0,[R9, #+7]
   \   000002D0   0C0097E5           LDR      R0,[R7, #+12]
   \   000002D4   000050E3           CMP      R0,#+0
   \   000002D8   B0FFFF0A           BEQ      ??ProcessNextSmile_8
   \   000002DC   00908DE5           STR      R9,[SP, #+0]
   \   000002E0   0000A0E3           MOV      R0,#+0
   \                     ??ProcessNextSmile_13:
   \   000002E4   0C1097E5           LDR      R1,[R7, #+12]
   \   000002E8   0D20A0E1           MOV      R2,SP
   \   000002EC   0220D0E7           LDRB     R2,[R0, +R2]
   \   000002F0   0120C0E7           STRB     R2,[R0, +R1]
   \   000002F4   010080E2           ADD      R0,R0,#+1
   \   000002F8   040050E3           CMP      R0,#+4
   \   000002FC   F8FFFFBA           BLT      ??ProcessNextSmile_13
   \   00000300   A7FFFFEA           B        ??ProcessNextSmile_9
    240            }
    241            //fclose(f,&err);
    242            total_smiles=0;
   \                     ??ProcessNextSmile_3:
   \   00000304   145084E5           STR      R5,[R4, #+20]
    243            p_buf=NULL;
    244            mfree(s_buf);
   \   00000308   240094E5           LDR      R0,[R4, #+36]
   \   0000030C   205084E5           STR      R5,[R4, #+32]
   \   00000310   150000EF           SWI      +21
    245            s_buf=NULL;
   \   00000314   245084E5           STR      R5,[R4, #+36]
    246            REDRAW();
   \   00000318   720100EF           SWI      +370
    247          }
   \   0000031C   84D08DE2           ADD      SP,SP,#+132
   \   00000320   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??ProcessNextSmile_5:
   \   00000324   5C000000           DC8      "\\",+0,+0
   \   00000328   ........           DC32     SMILE_PATH
    248          

   \                                 In segment CODE, align 4, keep-with-next
    249          void FreeXStatusesImg(void)
    250          {
   \                     FreeXStatusesImg:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    251          #ifdef GUI_INTERFACE
    252            void FreeXIconList();
    253            FreeXIconList();
    254          #else
    255            DYNPNGICONLIST *d;
    256            DYNPNGICONLIST *nd;
    257            LockSched();
   \   00000004   460100EF           SWI      +326
    258            total_xstatuses=0;
   \   00000008   44009FE5           LDR      R0,??FreeXStatusesImg_0  ;; total_xstatuses
   \   0000000C   0010A0E3           MOV      R1,#+0
   \   00000010   001080E5           STR      R1,[R0, #+0]
    259          //  d=XStatusesImgList;
    260          //  XStatusesImgList=0;
    261          //  mfree(XStatusesIconArray);
    262          //  XStatusesIconArray=NULL;
    263            UnlockSched();
   \   00000014   470100EF           SWI      +327
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   3080BD08           POPEQ    {R4,R5,PC}
    264            while(d)
                         ^
Warning[Pe549]: variable "d" is used before its value is set
    265            {
    266              if (d->img)
   \                     ??FreeXStatusesImg_1:
   \   00000020   080094E5           LDR      R0,[R4, #+8]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0300000A           BEQ      ??FreeXStatusesImg_2
    267              {
    268                mfree(d->img->bitmap);
   \   0000002C   040090E5           LDR      R0,[R0, #+4]
   \   00000030   150000EF           SWI      +21
    269                mfree(d->img);
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   150000EF           SWI      +21
    270              }
    271              nd=d->next;
   \                     ??FreeXStatusesImg_2:
   \   0000003C   005094E5           LDR      R5,[R4, #+0]
    272              mfree(d);
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   150000EF           SWI      +21
    273              d=nd;
   \   00000048   0540B0E1           MOVS     R4,R5
    274            }
   \   0000004C   F3FFFF1A           BNE      ??FreeXStatusesImg_1
    275          #endif
    276          }
   \   00000050   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??FreeXStatusesImg_0:
   \   00000054   ........           DC32     total_xstatuses
    277          

   \                                 In segment DATA_Z, align 4, align-sorted
    278          int xstatuses_max=0;
   \                     xstatuses_max:
   \   00000000                      DS8 4
    279          

   \                                 In segment CODE, align 4, keep-with-next
    280          void InitXStatusesImg(void)
    281          {/*
   \                     InitXStatusesImg:
   \   00000000   10402DE9           PUSH     {R4,LR}
    282            char fn[128];
    283            FSTATS stat;
    284            unsigned err;
    285            
    286            FreeXStatusesImg();
    287            total_xstatuses=0;
    288            *(XStatusesIconArray=malloc(sizeof(int)))=S_ICONS[IS_NULLICON];
    289            xstatuses_load=1;
    290            xstatuses_max=0;
    291            n_pic = FIRST_UCS2_BITMAP;
    292            gipc.name_to=ipc_my_name;
    293            gipc.name_from=ipc_my_name;
    294            gipc.data=0;
    295            
    296            pictures_max = 0;
    297            do
    298            {
    299              strcpy(fn,XSTATUSES_PATH);
    300              sprintf(fn+strlen(fn),"\\%d.png",pictures_max++);
    301              xstatuses_max++;
    302              if (GetFileStats(fn,&stat,&err)==-1) break;
    303            }  
    304            while (stat.size>0);
    305            pictures_max--;*/
    306            
    307            n_pic = FIRST_UCS2_BITMAP;
   \   00000004   ........           LDR      R4,??DataTable8  ;; gipc
   \   00000008   3700A0E3           MOV      R0,#+55
   \   0000000C   E10C80E3           ORR      R0,R0,#0xE100
   \   00000010   2C0084E5           STR      R0,[R4, #+44]
    308            pictures_max = 35;
   \   00000014   2300A0E3           MOV      R0,#+35
   \   00000018   180084E5           STR      R0,[R4, #+24]
    309            CheckSmiles();
   \   0000001C   ........           BL       CheckSmiles
    310          
    311          #ifndef GUI_INTERFACE  
    312            GBS_SendMessage(MMI_CEPID,MSG_IPC,IPC_XSTATUSIMG_PROCESSED,&gipc);
   \   00000020   0430A0E1           MOV      R3,R4
   \   00000024   0320A0E3           MOV      R2,#+3
   \   00000028   F210A0E3           MOV      R1,#+242
   \   0000002C   C01F81E3           ORR      R1,R1,#0x300
   \   00000030   0900A0E3           MOV      R0,#+9
   \   00000034   420C80E3           ORR      R0,R0,#0x4200
   \   00000038   000100EF           SWI      +256
    313          #endif
    314          }
   \   0000003C   1080BDE8           POP      {R4,PC}          ;; return
    315          
    316          
    317          #ifdef GUI_INTERFACE  
    318          /*
    319          typedef struct
    320          {
    321            void *next;
    322            int index;
    323            IMGHDR *img;
    324          }ICONS;
    325          */
    326          ICONS *xiconstop;
    327          
    328          int drawimg2img(IMGHDR * onse, IMGHDR * timage2, int x, int y, int xRect, int yRect,int xxRect, int yyRect);
    329          
    330          void AddXIcon(IMGHDR *img,int w,int h,int x,int x2,int ih)
    331          {
    332             ICONS *icon = malloc(sizeof(ICONS));
    333             icon->next = 0;
    334             icon->img = CreateImgr(w,h);//malloc(strlen(img->bitmap)+4);
    335             //memcpy(icon->img,img,strlen(img->bitmap)+4);
    336             drawimg2img(img,icon->img,0,0,x,0,x2,ih);
    337             if(!xiconstop)
    338             {
    339               icon->index = 0;
    340               xiconstop = icon;    
    341             }
    342             else
    343             {
    344          //    xiconstop->next = (ICONS*)icon;
    345               ICONS *ico=(ICONS *)xiconstop;
    346               int i=0;
    347               while(ico->next)
    348               {
    349                 ico=ico->next;
    350                 i++;
    351               }
    352               icon->index = i;
    353               ico->next = icon;
    354             }
    355          }
    356          
    357          
    358          void FreeXIconList()
    359          {  
    360            LockSched();
    361            ICONS *icon=(ICONS *)xiconstop;
    362            xiconstop=0;
    363            UnlockSched();
    364            while(icon)
    365            {
    366              ICONS *icon_prev = icon;
    367              icon = icon->next;
    368              if(icon_prev->img) mfree(icon_prev->img->bitmap);
    369              if(icon_prev) mfree(icon_prev);
    370            }
    371          }
    372          
    373          
    374          int CountXIcon()
    375          {
    376            int i=0;
    377            ICONS *ico=(ICONS *)xiconstop;
    378            while(ico){ i++; ico=ico->next; }
    379            return i;
    380          }
    381          
    382          
    383          
    384          int get_file_size(char* fname)
    385          {
    386            unsigned int err;
    387            FSTATS fs;
    388            if ((GetFileStats(fname,&fs,&err))==-1) return 0;
    389            return (fs.size);
    390          }
    391          
    392          
    393          
    394          IMGHDR *GetXIconByItem(int curitem)
    395          {
    396          //  if(curitem > CountXIcon()) return 0;
    397            
    398            ICONS *icon;
    399            icon=(ICONS *)xiconstop;
    400            int i=0;
    401          
    402            while(icon)
    403            {
    404              if(i==curitem) return (icon->img);// ? icon->img : 0;
    405              i++;
    406              icon=icon->next;  
    407            }
    408            return 0;
    409          }
    410          #endif
    411          

   \                                 In segment CODE, align 4, keep-with-next
    412          void ProcessNextXStatImg(void)
    413          {
    414           // char fn[128];
    415           // unsigned int err;
    416           // FSTATS stat;
    417          #ifdef GUI_INTERFACE
    418           // IMGHDR *img;
    419          #else
    420            DYNPNGICONLIST *dp;
    421            int i;
    422          #endif  
    423            
    424            //strcpy(fn,XSTATUSES_PATH);
    425            //sprintf(fn+strlen(fn),"\\%d.png",total_xstatuses);
    426           /* sprintf(fn,"%s\\%d.png",XSTATUSES_PATH,total_xstatuses);
    427            if (GetFileStats(fn,&stat,&err)!=-1)
    428            {
    429              if (stat.size>0)
    430              {
    431          #ifdef GUI_INTERFACE
    432                /*WSHDR *ws = AllocWS(256);
                       ^
Warning[Pe009]: nested comment is not allowed

    DYNPNGICONLIST *dp;
                    ^
"D:\pasha\elf\_MY_PROJECT_\_NATICQ2\check_smiles\smiles_loader.c",420  Warning[Pe177]: 
          variable "dp" was declared but never referenced

    int i;
        ^
"D:\pasha\elf\_MY_PROJECT_\_NATICQ2\check_smiles\smiles_loader.c",421  Warning[Pe177]: 
          variable "i" was declared but never referenced
    433                wsprintf(ws,fn);
    434                IMGHDR* CreateImgHdrByAnyFile (WSHDR * path,short width, short height, int rot);
    435                img = CreateImgHdrByAnyFile(ws,16,16,0);
    436              */
    437            /*   img = CreateIMGHDRFromPngFile(fn,0);
    438               AddXIcon(img);
    439          #else
    440                dp=malloc(sizeof(DYNPNGICONLIST));
    441                zeromem(dp,sizeof(DYNPNGICONLIST));
    442                dp->icon=i=GetPicNByUnicodeSymbol(n_pic);
    443                dp->img=CreateIMGHDRFromPngFile(fn,0);
    444                LockSched();
    445                if (XStatusesImgList)
    446                {
    447          	dp->next=XStatusesImgList;
    448                }
    449                XStatusesImgList=dp;
    450                UnlockSched();
    451          #endif
    452                total_xstatuses++;
    453                pictures_loaded++;
    454          #ifndef GUI_INTERFACE
    455                XStatusesIconArray=realloc(XStatusesIconArray,(total_xstatuses*sizeof(int)));
    456                *(XStatusesIconArray+(total_xstatuses-1))=i;
    457          #endif
    458                n_pic++;
    459                gipc.name_to=ipc_my_name;
    460                gipc.name_from=ipc_my_name;
    461                gipc.data=0;
    462                GBS_SendMessage(MMI_CEPID,MSG_IPC,IPC_XSTATUSIMG_PROCESSED,&gipc);
    463                return;
    464              }
    465            }  */
    466            xstatuses_load=0;
   \                     ProcessNextXStatImg:
   \   00000000   14009FE5           LDR      R0,??ProcessNextXStatImg_0  ;; xstatuses_load
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   0010A0E3           MOV      R1,#+0
   \   0000000C   001080E5           STR      R1,[R0, #+0]
    467            SUBPROC((void *)InitSmiles);
   \   00000010   08009FE5           LDR      R0,??ProcessNextXStatImg_0+0x4  ;; InitSmiles
   \   00000014   710100EF           SWI      +369
    468          }
   \   00000018   0080BDE8           POP      {PC}             ;; return
   \                     ??ProcessNextXStatImg_0:
   \   0000001C   ........           DC32     xstatuses_load
   \   00000020   ........           DC32     InitSmiles

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     SMILE_FILE

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     gipc

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     ipc_my_name

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     gipc

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   5C00               DC8 "\\"
    469          
    470          
    471          #ifdef GUI_INTERFACE
    472          
    473          
    474          extern const char *icons_names[];
    475          extern const char ICON_PATH[];
    476          
    477          
    478          ICONS *iconstop;
    479          
    480          void AddIcon(IMGHDR *img,int w,int h,int x,int x2,int ih)
    481          {
    482             ICONS *icon = malloc(sizeof(ICONS));
    483             icon->next = 0;
    484             icon->img = CreateImgr(w,h);//malloc(strlen(img->bitmap)+4);
    485             //memcpy(icon->img,img,strlen(img->bitmap)+4);
    486             drawimg2img(img,icon->img,0,0,x,0,x2,ih);
    487           
    488             if(!iconstop)
    489             {
    490               iconstop=icon; 
    491             }
    492             else
    493             {
    494                ICONS *ico=(ICONS *)iconstop;
    495                while(ico->next) ico = ico->next;
    496                ico->next=icon;
    497             }   
    498          }
    499          
    500          
    501          void FreeIconList()
    502          {  
    503            LockSched();
    504            ICONS *icon=(ICONS *)iconstop;
    505            iconstop=0;
    506            UnlockSched();
    507            while(icon)
    508            {
    509              ICONS *icon_prev = icon;
    510              icon = icon->next;
    511              if(icon_prev) mfree(icon_prev);
    512            }
    513          }
    514          
    515          int CountIcon()
    516          {
    517            int i=0;
    518            ICONS *ico=(ICONS *)iconstop;
    519            while(ico) { i++; ico=ico->next; }
    520            return i;
    521          }
    522          
    523          
    524          IMGHDR *GetIconByItem(int curitem)
    525          {
    526          //  if(curitem > CountIcon()) return 0;
    527            ICONS *icon;
    528            icon=(ICONS *)iconstop;
    529            int i=0;
    530          
    531            while(icon)
    532            {
    533              if(i==curitem) return (icon->img);
    534              i++;
    535              icon=icon->next;  
    536            }
    537            return 0;
    538          }
    539          
    540          
    541          //?????? ??????? ?? 1 ??????? ? ????? (?,y) ??????? ???????.
    542          int drawimg2img(IMGHDR * onse, IMGHDR * timage2, int x, int y, int xRect, int yRect,int xxRect, int yyRect)
    543          {
    544            //????????? ????????? - ???????? ??????? ?? ????????
    545            if (!onse) return 1;
    546            if (yRect<0 || yRect>=onse->h) yRect = 0;
    547            if (xRect<0 || xRect>=onse->w) xRect = 0;  // ??????? ? ???????? ?? ?????? ?????????? ?? ???:)
    548            if (yyRect==0 || (yRect+yyRect >= onse->h)) yyRect = onse->h-yRect; //e??? ?????? ??????? ??????? ??? ??????? ?? ????????, ?? ????? ?? ????? ???????? 
    549            if (xxRect==0 || (xRect+xxRect >= onse->w)) xxRect = onse->w-xRect; //e??? ?????? ??????? ??????? ??? ??????? ?? ????????, ?? ????? ?? ????? ???????? 
    550            int *scr = (int*)((char*)timage2->bitmap);
    551            int *pic = (int*)((char*)onse->bitmap);
    552            int i,j;
    553          
    554            for (i = xRect; i < xRect+xxRect; i++)
    555            {
    556              for(j = yRect; j < yRect+yyRect; j++)
    557              {
    558                //i ? ????????? ??????? ??? ??????? (?? xRect ?? xRect+xxRect)                                                                         //j ? ????????? ??????? ??? ??????? (?? yRect ?? yRect+yyRect)
    559                if (((y+j-yRect)<timage2->h) && ((x+i-xRect)<timage2->w) && ((y+j-yRect)>=0) && ((x+i-xRect)>=0) 
    560                    &&(i>=xRect)&&(j>=yRect)&&(i<xRect+xxRect)&&(j<yRect+yyRect))
    561                 {   
    562                   scr[(y+j-yRect)*timage2->w+i+x-xRect] = pic[(j)*onse->w+i];
    563                 }
    564              }
    565            }
    566           return 0;
    567          }
    568          
    569          
    570          POS status[]=
    571          {
    572            {IS_OFFLINE,    15,14},
    573            {IS_INVISIBLE,  14,14},
    574            {IS_AWAY,       15,14},
    575            {IS_NA,         15,14},
    576            {IS_OCCUPIED,   14,14},
    577            {IS_DND,        14,14},
    578            {IS_DEPRESSION, 15,14},
    579            {IS_EVIL,       15,14},
    580            {IS_HOME,       15,14},
    581            {IS_LUNCH,      16,14},
    582            {IS_WORK,       15,14},
    583            {IS_ONLINE,     14,14},
    584            {IS_FFC,        15,14},
    585            {IS_MSG,        14,14},
    586            {IS_UNKNOWN,    15,14},
    587            {IS_GROUP,      14,14},
    588            {IS_GROUPOFF,   14,14},
    589            {IS_NULLICON,   13,14},
    590            {ICON_ADDCONTACT,    14,14},
    591            {ICON_HEAD,       15,14},
    592            {ICON_LOGO,       0, 0},
    593            {ICON_PING,       15,14},
    594            {ICON_SETTINGS,   15,14},
    595            {ICON_ALL_CAN_SEE,          16,16},
    596            {ICON_VISLIST_CAN_SEE,      16,16},
    597            {ICON_INVISLIST_CANNOT_SEE, 16,16},
    598            {ICON_CONTACTLIST_CAN_SEE,  16,16},
    599            {ICON_NOBODY_CAN_SEE,       16,16},
    600            {ICON_CHECK,      14,14},
    601            {ICON_UNCHECK,    14,14}
    602          //  TOTAL_ICONS
    603          };
    604          
    605          void LoadImages()
    606          {
    607            char s[32];
    608            char s2[32];
    609          
    610            int i=0;
    611            IMGHDR *icon;
    612            {
    613                IMGHDR *img = CreateIMGHDRFromPngFile(MakeGlobalString(ICON_PATH,'\\',"status.png"),0);//("4:\\status.png",0);
    614          //      int size = 0;
    615                int start = 0;
    616                int i2 = 0;
    617          //      while(i<TOTAL_ICONS)
    618                for(int i = 0;i<TOTAL_ICONS;i++)
    619                {
    620                  if(i <= IS_FFC)
    621                  {
    622                    AddIcon(img,status[i].w,status[i].h,start,start + status[i].w,status[i].h);
    623                    /*
    624                    void AddIcon(IMGHDR *img,int w,int h,int x,int x2,int h)
    625                    icon = CreateImgr(status[i].w,status[i].h);            
    626                    drawimg2img(img,iconstop->img,0,0,start,0,start + status[i].w,status[i].h);            
    627                    //AddIcon(icon);
    628                    if(icon) mfree(icon);*/
    629                    start += status[i].w;
    630                  }
    631                  else
    632                  {
    633                    if(!i2)
    634                    {
    635                      if(img)  mfree(img);
    636                      img = CreateIMGHDRFromPngFile(MakeGlobalString(ICON_PATH,'\\',"image.png"),0);
    637                      i2 = 1;
    638                      start = 0;
    639                    }
    640                    if(i == ICON_LOGO)
    641                    {
    642                     // if(icon) mfree(icon);
    643                      icon = CreateIMGHDRFromPngFile( MakeGlobalString(ICON_PATH,'\\',icons_names[ICON_LOGO]),0);
    644                      AddIcon(icon,icon->w,icon->h,0,icon->w,icon->h);
    645                      if(icon)  mfree(icon);
    646                      i++;
    647                    }
    648                    /*
    649                    icon = CreateImgr(status[i].w, status[i].h);
    650                    drawimg2img(img,icon,0,0,start,0,start + status[i].w,status[i].h);
    651                    AddIcon(icon);
    652                     if(icon) mfree(icon);*/
    653                    AddIcon(img,status[i].w,status[i].h,start,start + status[i].w,status[i].h);
    654                    start += status[i].w + (i >= ICON_ALL_CAN_SEE && i <= ICON_NOBODY_CAN_SEE?1:0);
    655                    if(start > img->w) break;
    656                  }
    657                 }
    658          
    659                icon = CreateIMGHDRFromPngFile( MakeGlobalString(ICON_PATH,'\\',icons_names[ICON_BG]),0);
    660                AddIcon(icon,icon->w,icon->h,0,icon->w,icon->h);
    661                if(icon) mfree(icon);
    662                
    663                mfree(img);
    664                img = CreateIMGHDRFromPngFile(MakeGlobalString(ICON_PATH,'\\',"xst.png"),0);
    665                start = 0;
    666                total_xstatuses = 0;
    667                for(int i=0;i<35;i++)
    668                 {
    669                    AddXIcon(img,16,16,start,start + 16,16);
    670                    start += 17;
    671                    xstatuses_max = total_xstatuses++;
    672                    pictures_max++;
    673                    pictures_loaded++;
    674                    if(start > img->w) break;
    675                 }
    676              mfree(img);
    677            }
    678              /*  else
    679              {
    680                 strcpy(s2,icons_names[i]);
    681                 s2[strlen(s2)-4]=0;//отрезаем '.png'
    682                 snprintf(s,32,"%s_small.png",s2);
    683              
    684                 if( get_file_size(MakeGlobalString(ICON_PATH,'\\',s)) )
    685                     icon = CreateIMGHDRFromPngFile( MakeGlobalString(ICON_PATH,'\\',s), 0 );   
    686                 else
    687                    icon = CreateIMGHDRFromPngFile( MakeGlobalString(ICON_PATH,'\\',icons_names[i]), 0 );
    688                  
    689                AddIcon(icon);
    690                i++;
    691              }*/
    692          }
    693          
    694          
    695          
    696          void ProcessNextImg(void)
    697          {
    698            xstatuses_load=0;
    699            SUBPROC((void *)InitSmiles);
    700          //   SUBPROC((void *)ProcessNextXStatImg);
    701           // GBS_SendMessage(MMI_CEPID,MSG_IPC,IPC_XSTATUSIMG_PROCESSED,&gipc);
    702          }
    703          #endif

   Maximum stack usage in bytes:

     Function            CSTACK
     --------            ------
     CheckSmiles            64
     FreeSmiles             28
     FreeXStatusesImg       12
     InitSmiles             68
     InitXStatusesImg        8
     ProcessNextSmile      160
     ProcessNextXStatImg     4


   Segment part sizes:

     Function/Label      Bytes
     --------------      -----
     gipc                  48
     total_xstatuses        4
     xstatuses_load         4
     FreeSmiles           212
     InitSmiles           212
     CheckSmiles          228
     ProcessNextSmile     812
     FreeXStatusesImg      88
     xstatuses_max          4
     InitXStatusesImg      64
     ProcessNextXStatImg   36
     ??DataTable4           4
     ??DataTable5           4
     ??DataTable7           4
     ??DataTable8           4
     ?<Constant "\\">       2
      Others               40

 
 1 696 bytes in segment CODE
     2 bytes in segment DATA_C
    60 bytes in segment DATA_Z
    12 bytes in segment INITTAB
 
 1 668 bytes of CODE  memory (+ 40 bytes shared)
     2 bytes of CONST memory
    60 bytes of DATA  memory

Errors: none
Warnings: 4
